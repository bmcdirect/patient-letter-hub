generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String   @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @default(now()) @map("updated_at")
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

model Practice {
  id             String               @id @default(cuid())
  name           String
  address        String?
  phone          String?
  email          String?
  createdAt      DateTime             @default(now()) @map("created_at")
  updatedAt      DateTime             @default(now()) @map("updated_at")
  organizationId String?
  addressLine1   String?
  addressLine2   String?
  city           String?
  state          String?
  zipCode        String?
  emails         EmailNotifications[] @relation("PracticeEmails")
  invoices       Invoices[]           @relation("PracticeInvoices")
  orders         Orders[]             @relation("PracticeOrders")
  quotes         Quotes[]             @relation("PracticeQuotes")
  users          User[]

  @@map("practices")
}

model User {
  id                     String               @id @default(cuid())
  name                   String?
  email                  String?              @unique
  emailVerified          DateTime?
  image                  String?
  createdAt              DateTime             @default(now()) @map("created_at")
  updatedAt              DateTime             @default(now()) @map("updated_at")
  role                   UserRole             @default(USER)
  stripeCustomerId       String?              @unique @map("stripe_customer_id")
  stripeSubscriptionId   String?              @unique @map("stripe_subscription_id")
  stripePriceId          String?              @map("stripe_price_id")
  stripeCurrentPeriodEnd DateTime?            @map("stripe_current_period_end")
  practiceId             String?
  clerkId                String?              @unique
  npi1                   String?
  npi2                   String?
  taxonomyCode           String?
  title                  String?
  accounts               Account[]
  emails                 EmailNotifications[] @relation("UserEmails")
  invoices               Invoices[]           @relation("UserInvoices")
  approvals              OrderApprovals[]     @relation("UserApprovals")
  uploadedFiles          OrderFiles[]         @relation("UserUploadedFiles")
  statusChanges          OrderStatusHistory[] @relation("UserStatusChanges")
  orders                 Orders[]             @relation("UserOrders")
  proofs                 Proof[]              @relation("UserProofs")
  quotes                 Quotes[]             @relation("UserQuotes")
  sessions               Session[]
  practice               Practice?            @relation(fields: [practiceId], references: [id], onDelete: Cascade)

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Orders {
  id                  String               @id @default(cuid())
  orderNumber         String               @unique
  practiceId          String
  userId              String
  status              String
  subject             String?
  templateType        String?
  colorMode           String?
  cost                Float?
  createdAt           DateTime             @default(now()) @map("created_at")
  updatedAt           DateTime             @default(now()) @map("updated_at")
  fulfilledAt         DateTime?
  preferredMailDate   DateTime?
  productionEndDate   DateTime?
  productionStartDate DateTime?
  emails              EmailNotifications[] @relation("OrderEmails")
  invoices            Invoices[]           @relation("OrderInvoices")
  approvals           OrderApprovals[]
  files               OrderFiles[]
  statusHistory       OrderStatusHistory[] @relation("OrderStatusHistory")
  practice            Practice             @relation("PracticeOrders", fields: [practiceId], references: [id], onDelete: Cascade)
  user                User                 @relation("UserOrders", fields: [userId], references: [id], onDelete: Cascade)
  proofs              Proof[]

  @@map("orders")
}

model OrderFiles {
  id         String   @id @default(cuid())
  orderId    String
  fileName   String
  filePath   String
  fileType   String?
  uploadedBy String
  createdAt  DateTime @default(now()) @map("created_at")
  order      Orders   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  uploader   User     @relation("UserUploadedFiles", fields: [uploadedBy], references: [id], onDelete: Cascade)

  @@map("order_files")
}

model OrderApprovals {
  id               String    @id @default(cuid())
  orderId          String
  revision         Int
  status           String
  comments         String?
  approvedBy       String
  createdAt        DateTime  @default(now()) @map("created_at")
  adminNotes       String?
  escalationReason String?
  filePath         String?
  proofId          String?   @unique
  respondedAt      DateTime?
  userFeedback     String?
  approver         User      @relation("UserApprovals", fields: [approvedBy], references: [id], onDelete: Cascade)
  order            Orders    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  proof            Proof?    @relation(fields: [proofId], references: [id])

  @@map("order_approvals")
}

model Proof {
  id               String          @id @default(cuid())
  orderId          String
  proofRound       Int
  fileUrl          String?
  filePath         String?
  status           ProofStatus     @default(PENDING)
  userFeedback     String?
  adminNotes       String?
  uploadedBy       String
  uploadedAt       DateTime        @default(now())
  respondedAt      DateTime?
  escalationReason String?
  approval         OrderApprovals?
  order            Orders          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  uploader         User            @relation("UserProofs", fields: [uploadedBy], references: [id], onDelete: Cascade)

  @@unique([orderId, proofRound])
  @@map("proofs")
}

model OrderStatusHistory {
  id            String   @id @default(cuid())
  orderId       String
  fromStatus    String
  toStatus      String
  changedBy     String
  changedByRole UserRole
  comments      String?
  metadata      Json?
  createdAt     DateTime @default(now()) @map("created_at")
  user          User     @relation("UserStatusChanges", fields: [changedBy], references: [id], onDelete: Cascade)
  order         Orders   @relation("OrderStatusHistory", fields: [orderId], references: [id], onDelete: Cascade)

  @@map("order_status_history")
}

model Quotes {
  id                  String   @id @default(cuid())
  practiceId          String
  userId              String
  quoteNumber         String   @unique
  status              String
  totalCost           Float?
  createdAt           DateTime @default(now()) @map("created_at")
  colorMode           String?
  costCenter          String?
  dataCleansing       Boolean?
  estimatedRecipients Int?
  firstClassPostage   Boolean?
  ncoaUpdate          Boolean?
  notes               String?
  purchaseOrder       String?
  subject             String?
  practice            Practice @relation("PracticeQuotes", fields: [practiceId], references: [id], onDelete: Cascade)
  user                User     @relation("UserQuotes", fields: [userId], references: [id], onDelete: Cascade)

  @@map("quotes")
}

model Invoices {
  id            String   @id @default(cuid())
  invoiceNumber String   @unique
  orderId       String
  userId        String
  practiceId    String
  invoiceDate   String
  dueDate       String
  subtotal      String
  taxAmount     String
  totalAmount   String
  status        String   @default("draft")
  paymentTerms  String   @default("Net 30")
  notes         String?
  pdfPath       String?
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @default(now()) @map("updated_at")
  order         Orders   @relation("OrderInvoices", fields: [orderId], references: [id], onDelete: Cascade)
  practice      Practice @relation("PracticeInvoices", fields: [practiceId], references: [id], onDelete: Cascade)
  user          User     @relation("UserInvoices", fields: [userId], references: [id], onDelete: Cascade)

  @@map("invoices")
}

model EmailNotifications {
  id             String    @id @default(cuid())
  orderId        String?
  userId         String
  practiceId     String?
  recipientEmail String
  emailType      String
  subject        String
  content        String
  status         String    @default("sent")
  sentAt         DateTime  @default(now())
  errorMessage   String?
  metadata       String?
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @default(now()) @map("updated_at")
  order          Orders?   @relation("OrderEmails", fields: [orderId], references: [id], onDelete: Cascade)
  practice       Practice? @relation("PracticeEmails", fields: [practiceId], references: [id], onDelete: Cascade)
  user           User      @relation("UserEmails", fields: [userId], references: [id], onDelete: Cascade)

  @@map("email_notifications")
}

model WebhookEvent {
  id          String   @id
  processedAt DateTime @default(now())
}

enum UserRole {
  ADMIN
  USER
}

enum ProofStatus {
  PENDING
  APPROVED
  CHANGES_REQUESTED
  ESCALATED
}
